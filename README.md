好的，这是您提供的 README 内容转换成的 Markdown 格式。

-----

# 第一次培训作业 - README

## 1\. 项目概述

本项目是基于 `STM32 HAL` 库和 `CMake` 工具链完成的培训作业。项目通过模块化的 C++ 任务封装，实现了三个核心功能：

  * **LED 闪烁**：使用 `TIM1` 定时器中断精确控制板载 LED 以 1Hz 的频率闪烁。
  * **UART 串口通讯**：实现一个自定义的 9 字节通讯协议，使用 `UART1` 发送，`UART2` 通过 **`DMA+空闲中断`** 的方式高效接收，并在主函数中获取解析后的数据。
  * **CAN 总线通讯**：实现一个自定义的 8 字节通讯协议，使用 CAN 的 `Loopback`（环回）模式进行自发自收测试。CAN 任务配置了硬件过滤器，仅接收 ID 为 `0x100` 的报文。

项目采用了 C 和 C++ 混合编程的最佳实践，通过 C 风格的接口函数将 C++ 任务无缝集成到 `main.c` 主流程中。

## 2\. 主要功能特性

**定时器中断：**

  * 使用 `TIM1` 作为系统的心跳时钟 (tick)，中断频率为 2kHz (0.5ms)。
  * 在定时器中断中实现 LED 的 1Hz 闪烁逻辑。

**UART 异步通讯：**

  * **自定义协议**：采用 9 字节数据帧，包含 3 字节帧头 (`0xAA 0xBB 0xCC`)、4 字节 `tick` 和 2 字节 `value`。
  * **高效接收**：接收端使用 `DMA + 空闲中断` (IDLE Interrupt) 机制，不占用 CPU 资源，能够高效处理数据流。
  * **C++ 封装**：将所有 UART 逻辑封装在 `UartTask` 类中，管理自身的状态机和缓冲区，代码结构清晰。

**CAN 回环通讯：**

  * **自定义协议**：采用 8 字节数据帧，将 `tick`, `value1`, `value2` 以及 4 个布尔标志位打包其中。
  * **硬件过滤**：精确配置 CAN 硬件过滤器，仅接收 ID 为 `0x100` 的标准数据帧，减轻 CPU 负担。
  * **自测模式**：CAN 外设工作在 `Loopback` 模式，无需外部 CAN 收发器即可完成自发自收测试。
  * **分层设计**：`can_task` 任务层调用了 `HW_can.cpp` 中提供的底层发送函数 `CAN_Send_Msg`，实现了逻辑与驱动的分离。

## 3\. 项目文件结构

```
/HW_1
|
|-- /Core
|   |-- /Inc
|   |   |-- main.h
|   |   |-- tim.h
|   |   |-- ...
|   |-- /Src
|   |   |-- main.c           # 主程序入口，任务调度
|   |   |-- tim.c            # TIM1 初始化与中断回调 (tick 和 LED)
|   |   |-- stm32f1xx_it.c   # 中断服务程序
|   |   |-- ...
|
|-- /Tasks                   # 任务层代码
|   |-- uart_task.hpp        # UART 任务的头文件 (C++/C 接口)
|   |-- uart_task.cpp        # UART 任务的实现
|   |-- can_task.hpp         # CAN 任务的头文件 (C++/C 接口)
|   |-- can_task.cpp         # CAN 任务的实现
|
|-- /Resources               # 底层驱动或资源文件
|   |-- HW_can.hpp           # 提供的底层 CAN 驱动头文件
|   |-- HW_can.cpp           # 提供的底层 CAN 驱动实现
|
|-- CMakeLists.txt           # CMake 配置文件
|-- README.md                # 本文档
```

## 4\. 如何编译与使用

### 4.1. 硬件连接 (用于测试)

  * **UART**：使用杜邦线将开发板上的 `UART1_TX` 引脚连接到 `UART2_RX` 引脚，以实现自发自收。
  * **CAN**：无需任何外部连接。CAN 外设已配置为 `Loopback` 模式。
  * **LED**：`PC13` 板载 LED。

### 4.2. 软件环境

  * **STM32CubeMX**: 用于生成硬件初始化代码。
  * **ARM GCC Toolchain**: 用于编译。
  * **CMake & Ninja**: 用于构建项目。

## 5\. 如何验证

使用调试器（如 Ozone、GDB 或 Keil/IAR 的调试功能）是验证本项目功能的最佳方式。

1.  **编译并烧录**
2.  **启动调试会话**
3.  **设置断点**
4.  **观察变量**：
      * **UART**：程序在断点处暂停后，在变量观察窗口中查看 `received_data` 结构体。您应该能看到其成员 `tick` 在稳定增长，`value` 在 -1.0 到 1.0 之间呈正弦变化。
      * **CAN**：同样地，观察 `received_can_data` 结构体。您会看到其成员 `tick`, `value1`, `value2`, `flag1` 等都在按预期规律变化，并且发送和接收的数据完全一致。
      * **LED**：让程序全速运行，观察板载的 `PC13` LED 是否以大约 1 秒 1 次的频率稳定闪烁。